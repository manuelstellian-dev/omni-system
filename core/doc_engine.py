"""
OMNI Documentation Engine

Automatically generates professional, context-aware documentation including:
- README.md with setup instructions
- Architecture Decision Records (ADRs)
- API documentation (future enhancement)

Implements the OMNI capability of maintaining comprehensive project documentation
that evolves with the codebase.
"""

import os
import litellm
from pathlib import Path
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel
from cortex import ProjectSpec


console = Console()


class DocEngine:
    def __init__(self):
        """Initialize the Documentation Engine."""
        self.model = os.getenv("OMNI_MODEL", "gpt-4o")

    def generate_documentation(self, spec: ProjectSpec, target_dir: str):
        """
        Generates comprehensive documentation for the project.

        Creates:
        1. README.md - Main project documentation with setup and deployment instructions
        2. ADR-0001-database-choice.md - Architecture Decision Record for database selection
        3. docs/adr/ folder structure for future ADRs

        Args:
            spec: ProjectSpec containing project information
            target_dir: Target directory where documentation will be generated
        """
        target_path = Path(target_dir)
        target_path.mkdir(parents=True, exist_ok=True)

        console.print(Panel.fit(
            f"[bold magenta]DOCUMENTATION ENGINE ACTIVATED[/bold magenta]\n\n"
            f"Generating professional documentation for: {spec.project_name}",
            border_style="magenta"
        ))

        # Create documentation directory structure
        docs_path = target_path / "docs"
        adr_path = docs_path / "adr"
        adr_path.mkdir(parents=True, exist_ok=True)

        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console,
        ) as progress:
            # Generate README.md
            task_readme = progress.add_task(
                "[cyan]Generating project README.md...",
                total=None
            )

            readme_content = self._generate_readme(spec)
            readme_path = target_path / "README.md"

            # Only generate if README doesn't exist or is a fallback
            if not readme_path.exists() or self._is_fallback_readme(readme_path):
                with open(readme_path, "w") as f:
                    f.write(readme_content)
                progress.update(task_readme, completed=True)
                console.print("[green]✓[/green] README.md")
            else:
                progress.update(task_readme, completed=True)
                console.print("[yellow]⊙[/yellow] README.md (already exists, skipping)")

            # Generate Architecture Decision Records
            task_adr = progress.add_task(
                "[cyan]Generating Architecture Decision Records...",
                total=None
            )

            # ADR for Database Choice
            adr_db_content = self._generate_adr_database(spec)
            adr_db_path = adr_path / "ADR-0001-database-choice.md"

            with open(adr_db_path, "w") as f:
                f.write(adr_db_content)

            progress.update(task_adr, completed=True)
            console.print("[green]✓[/green] docs/adr/ADR-0001-database-choice.md")

            # Generate ADR for Tech Stack (bonus)
            adr_stack_content = self._generate_adr_tech_stack(spec)
            adr_stack_path = adr_path / "ADR-0002-tech-stack.md"

            with open(adr_stack_path, "w") as f:
                f.write(adr_stack_content)

            console.print("[green]✓[/green] docs/adr/ADR-0002-tech-stack.md")

        console.print(f"\n[bold green]✓ Documentation generation complete![/bold green]\n")

    def _is_fallback_readme(self, readme_path: Path) -> bool:
        """Check if the existing README is just a fallback/placeholder."""
        try:
            with open(readme_path, 'r') as f:
                content = f.read()
                # Simple heuristic: fallback READMEs are usually very short
                return len(content) < 500 or "Generated by OMNI" in content
        except Exception:
            return False

    def _generate_readme(self, spec: ProjectSpec) -> str:
        """
        Generates a comprehensive README.md using LLM.
        """
        prompt = f"""Generate a professional, comprehensive README.md for the following project.

Project Name: {spec.project_name}
Tech Stack: {', '.join(spec.tech_stack)}
Core Features: {', '.join(spec.core_features)}
Database: {self._extract_database_from_schema(spec.database_schema)}

The README must include:

1. **Project Title and Description**
   - Clear, concise description of what the project does
   - Key value propositions

2. **Features**
   - List all core features from the spec
   - Use bullet points with brief explanations

3. **Tech Stack**
   - List all technologies used
   - Explain why each was chosen (modern, production-grade)

4. **Prerequisites**
   - Node.js version (if applicable)
   - Python version (if applicable)
   - Docker and Docker Compose
   - Database requirements
   - API keys needed (Stripe, Resend, etc.)

5. **Installation & Setup**
   - Step-by-step installation instructions
   - Environment variable configuration (.env.example reference)
   - Database setup (migrations, seeding)
   - Detailed setup for each technology in the stack

6. **Development**
   - How to run the development server
   - How to run tests
   - How to run linting
   - Common development tasks

7. **Deployment**
   - Docker deployment instructions (using docker-compose)
   - Production environment variables
   - CI/CD pipeline overview (GitHub Actions)
   - Deployment platforms (Vercel, Railway, AWS, etc.)

8. **Project Structure**
   - Brief overview of main directories and their purpose

9. **Contributing**
   - Guidelines for contributors (if applicable)

10. **License**
    - Standard open-source license notice

CRITICAL RULES:
1. Output ONLY the raw Markdown content. NO code blocks wrapping it.
2. Use proper Markdown formatting (headers, lists, code blocks for commands).
3. Be specific and actionable - real commands, not placeholders.
4. Professional tone, comprehensive but concise.
5. Include actual command examples with proper syntax.
6. Make it production-ready documentation.

Generate the README.md content now:
"""

        try:
            response = litellm.completion(
                model=self.model,
                messages=[
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
            )

            return response.choices[0].message.content.strip()

        except Exception as e:
            console.print(f"[yellow]Warning: LLM generation failed for README, using fallback[/yellow]")
            return self._get_fallback_readme(spec)

    def _generate_adr_database(self, spec: ProjectSpec) -> str:
        """
        Generates an Architecture Decision Record for the database choice.
        """
        database_info = self._extract_database_from_schema(spec.database_schema)

        prompt = f"""Generate an Architecture Decision Record (ADR) for the database choice in this project.

Project Name: {spec.project_name}
Tech Stack: {', '.join(spec.tech_stack)}
Database Choice: {database_info}
Database Schema: {spec.database_schema[:500]}...

Use the standard ADR template with these sections:

# ADR-0001: Database Choice

## Status
Accepted

## Context
[Explain the project requirements and why a database decision was needed]

## Decision
[State the specific database and ORM choice, e.g., "We will use PostgreSQL with Prisma ORM"]

## Rationale
[Explain WHY this choice was made - technical reasons, benefits, alignment with project needs]

## Consequences

### Positive
[List the benefits and advantages of this choice]

### Negative
[List any drawbacks, trade-offs, or challenges]

### Neutral
[List any neutral implications or things to be aware of]

## Alternatives Considered
[List other options that were considered and why they weren't chosen]

CRITICAL RULES:
1. Output ONLY the raw Markdown content. NO code blocks wrapping it.
2. Use professional, technical language.
3. Be specific about the actual technology choices from the tech stack.
4. Justify decisions with concrete technical reasoning.
5. Date the decision as today.
6. Make it realistic and comprehensive.

Generate the ADR content now:
"""

        try:
            response = litellm.completion(
                model=self.model,
                messages=[
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
            )

            return response.choices[0].message.content.strip()

        except Exception as e:
            console.print(f"[yellow]Warning: LLM generation failed for ADR, using fallback[/yellow]")
            return self._get_fallback_adr_database(spec, database_info)

    def _generate_adr_tech_stack(self, spec: ProjectSpec) -> str:
        """
        Generates an Architecture Decision Record for the tech stack choice.
        """
        prompt = f"""Generate an Architecture Decision Record (ADR) for the overall tech stack choice in this project.

Project Name: {spec.project_name}
Tech Stack: {', '.join(spec.tech_stack)}
Core Features: {', '.join(spec.core_features)}

Use the standard ADR template with these sections:

# ADR-0002: Tech Stack Selection

## Status
Accepted

## Context
[Explain the project requirements and the need for a modern, scalable tech stack]

## Decision
[State the specific technology choices: framework, language, libraries, tools]

## Rationale
[Explain WHY these technologies were chosen together - synergies, ecosystem, developer experience]

## Consequences

### Positive
[List the benefits of this tech stack combination]

### Negative
[List any drawbacks or complexity introduced]

### Neutral
[List neutral implications]

## Alternatives Considered
[List other tech stacks that could have been used]

CRITICAL RULES:
1. Output ONLY the raw Markdown content. NO code blocks wrapping it.
2. Use professional, technical language.
3. Explain the synergies between the chosen technologies.
4. Justify why this stack is production-grade and modern.
5. Date the decision as today.

Generate the ADR content now:
"""

        try:
            response = litellm.completion(
                model=self.model,
                messages=[
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
            )

            return response.choices[0].message.content.strip()

        except Exception as e:
            console.print(f"[yellow]Warning: LLM generation failed for tech stack ADR, using fallback[/yellow]")
            return self._get_fallback_adr_tech_stack(spec)

    def _extract_database_from_schema(self, schema: str) -> str:
        """Extract database type from schema description."""
        schema_lower = schema.lower()

        if "postgresql" in schema_lower or "postgres" in schema_lower:
            return "PostgreSQL"
        elif "mysql" in schema_lower:
            return "MySQL"
        elif "mongodb" in schema_lower or "mongo" in schema_lower:
            return "MongoDB"
        elif "sqlite" in schema_lower:
            return "SQLite"
        else:
            return "PostgreSQL (default)"

    def _get_fallback_readme(self, spec: ProjectSpec) -> str:
        """Fallback README if LLM fails."""
        return f"""# {spec.project_name}

## Overview

A modern, production-ready application built with {', '.join(spec.tech_stack[:3])}.

## Features

{chr(10).join(f"- {feature}" for feature in spec.core_features)}

## Tech Stack

{chr(10).join(f"- {tech}" for tech in spec.tech_stack)}

## Prerequisites

- Node.js 20+ (for Next.js projects)
- Python 3.12+ (for Python projects)
- Docker and Docker Compose
- PostgreSQL (or your chosen database)

## Installation

```bash
# Clone the repository
git clone https://github.com/your-username/{spec.project_name}.git
cd {spec.project_name}

# Install dependencies
npm install  # or pip install -r requirements.txt

# Set up environment variables
cp .env.example .env
# Edit .env with your configuration

# Run database migrations
npx prisma migrate dev  # if using Prisma

# Start development server
npm run dev  # or python main.py
```

## Development

```bash
# Run development server
npm run dev

# Run tests
npm test

# Run linting
npm run lint
```

## Deployment

```bash
# Using Docker
docker-compose up -d

# Using npm
npm run build
npm start
```

## License

MIT
"""

    def _get_fallback_adr_database(self, spec: ProjectSpec, database: str) -> str:
        """Fallback ADR for database if LLM fails."""
        from datetime import date

        return f"""# ADR-0001: Database Choice

**Date**: {date.today().isoformat()}
**Status**: Accepted
**Deciders**: OMNI Architecture Team

## Context

The {spec.project_name} project requires a robust, scalable database solution to support {len(spec.core_features)} core features including data persistence, querying, and transactional integrity.

## Decision

We will use **{database}** as the primary database with **Prisma ORM** for type-safe database access.

## Rationale

1. **Reliability**: {database} is proven in production environments
2. **ACID Compliance**: Full transactional support for data integrity
3. **Scalability**: Can scale horizontally and vertically as needed
4. **Ecosystem**: Excellent tooling and community support
5. **Type Safety**: Prisma provides end-to-end type safety with TypeScript

## Consequences

### Positive
- Strong data consistency guarantees
- Mature ecosystem with extensive documentation
- Excellent performance for relational data
- Migration tooling via Prisma

### Negative
- Requires infrastructure setup (vs. serverless databases)
- Vertical scaling has limits

### Neutral
- Team needs familiarity with SQL and Prisma
- Backup and recovery procedures must be established

## Alternatives Considered

- **MongoDB**: Considered for flexibility, but our schema is highly relational
- **MySQL**: Similar benefits to PostgreSQL, but slightly less feature-rich
- **Supabase**: Considered for hosted PostgreSQL with built-in features
"""

    def _get_fallback_adr_tech_stack(self, spec: ProjectSpec) -> str:
        """Fallback ADR for tech stack if LLM fails."""
        from datetime import date

        return f"""# ADR-0002: Tech Stack Selection

**Date**: {date.today().isoformat()}
**Status**: Accepted
**Deciders**: OMNI Architecture Team

## Context

The {spec.project_name} project requires a modern, production-grade tech stack that enables rapid development while maintaining code quality, type safety, and scalability.

## Decision

We will use the following tech stack:

{chr(10).join(f"- **{tech}**" for tech in spec.tech_stack)}

## Rationale

1. **Type Safety**: TypeScript provides compile-time error detection
2. **Modern Framework**: Next.js 15 offers server components and optimized performance
3. **Developer Experience**: Excellent tooling and ecosystem
4. **Production Ready**: All technologies are battle-tested in production
5. **Opinionated Excellence**: Enforces best practices by default

## Consequences

### Positive
- Fast development iteration
- Strong type safety reduces runtime errors
- Excellent performance out of the box
- Large community and ecosystem
- Clear upgrade paths

### Negative
- Learning curve for team members unfamiliar with the stack
- Locked into Node.js ecosystem (for Next.js projects)

### Neutral
- Requires modern build tooling
- Regular updates needed to stay current

## Alternatives Considered

- **Django + React**: More separation but less integrated developer experience
- **Ruby on Rails**: Great DX but smaller TypeScript ecosystem
- **Laravel + Vue**: Mature but not as TypeScript-first
"""
